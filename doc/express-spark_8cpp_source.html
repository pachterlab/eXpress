<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>eXpress: src/express-spark.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_small.png"></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">eXpress&#160;<span id="projectnumber">1.3.1</span></div>
   <div id="projectbrief"><a href=http://bio.math.berkeley.edu/eXpress>http://bio.math.berkeley.edu/eXpress</a></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('express-spark_8cpp.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<h1>src/express-spark.cpp</h1>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">//</span>
<a name="l00002"></a>00002 <span class="comment">//  main.cpp</span>
<a name="l00003"></a>00003 <span class="comment">//  express-spark</span>
<a name="l00004"></a>00004 <span class="comment">//</span>
<a name="l00005"></a>00005 <span class="comment">//  Created by Adam Roberts on 10/15/12.</span>
<a name="l00006"></a>00006 <span class="comment">//</span>
<a name="l00007"></a>00007 <span class="comment">//</span>
<a name="l00008"></a>00008 
<a name="l00009"></a>00009 <span class="preprocessor">#include &lt;boost/program_options.hpp&gt;</span>
<a name="l00010"></a>00010 <span class="preprocessor">#include &lt;boost/thread.hpp&gt;</span>
<a name="l00011"></a>00011 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00012"></a>00012 <span class="preprocessor">#include &lt;iomanip&gt;</span>
<a name="l00013"></a>00013 <span class="preprocessor">#include &lt;fstream&gt;</span>
<a name="l00014"></a>00014 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00015"></a>00015 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00016"></a>00016 <span class="preprocessor">#include &quot;targets.h&quot;</span>
<a name="l00017"></a>00017 <span class="preprocessor">#include &quot;fragments.h&quot;</span>
<a name="l00018"></a>00018 <span class="preprocessor">#include &quot;biascorrection.h&quot;</span>
<a name="l00019"></a>00019 <span class="preprocessor">#include &quot;mismatchmodel.h&quot;</span>
<a name="l00020"></a>00020 <span class="preprocessor">#include &quot;mapparser.h&quot;</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &quot;threadsafety.h&quot;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &quot;robertsfilter.h&quot;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &quot;library.h&quot;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &quot;main.h&quot;</span>
<a name="l00025"></a>00025 
<a name="l00026"></a>00026 <span class="preprocessor">#ifndef WIN32</span>
<a name="l00027"></a>00027 <span class="preprocessor"></span><span class="preprocessor">#include &quot;update_check.h&quot;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#endif</span>
<a name="l00029"></a>00029 <span class="preprocessor"></span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &quot;proto/alignments.pb.h&quot;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &quot;proto/targets.pb.h&quot;</span>
<a name="l00032"></a>00032 
<a name="l00033"></a>00033 <span class="preprocessor">#include &lt;boost/archive/iterators/base64_from_binary.hpp&gt;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &lt;boost/archive/iterators/transform_width.hpp&gt;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &lt;boost/archive/iterators/ostream_iterator.hpp&gt;</span>
<a name="l00036"></a>00036 
<a name="l00037"></a>00037 <span class="keyword">using namespace </span>std;
<a name="l00038"></a>00038 
<a name="l00039"></a>00039 <span class="keyword">namespace </span>po = boost::program_options;
<a name="l00040"></a>00040 
<a name="l00041"></a>00041 <span class="keywordtype">string</span> target_output = <span class="stringliteral">&quot;targets.pb&quot;</span>;
<a name="l00042"></a>00042 <span class="keywordtype">string</span> in_map_filename = <span class="stringliteral">&quot;&quot;</span>;
<a name="l00043"></a>00043 <span class="keywordtype">string</span> fasta_filename = <span class="stringliteral">&quot;&quot;</span>;
<a name="l00044"></a>00044 <span class="keywordtype">size_t</span> stop_at = 0;
<a name="l00045"></a>00045 
<a name="l00046"></a>00046 <span class="keywordtype">bool</span> edit_detect = <span class="keyword">false</span>;
<a name="l00047"></a>00047 <span class="keywordtype">bool</span> running = <span class="keyword">true</span>;
<a name="l00048"></a>00048 <span class="keywordtype">bool</span> burned_out = <span class="keyword">true</span>;
<a name="l00049"></a>00049 <span class="keywordtype">size_t</span> max_indel_size = 10;
<a name="l00050"></a>00050 Direction direction = BOTH;
<a name="l00051"></a>00051 
<a name="l00058"></a>00058 <span class="keywordtype">bool</span> parse_options(<span class="keywordtype">int</span> ac, <span class="keywordtype">char</span> ** av) {
<a name="l00059"></a>00059   po::options_description standard(<span class="stringliteral">&quot;Standard Options&quot;</span>);
<a name="l00060"></a>00060   standard.add_options()
<a name="l00061"></a>00061   (<span class="stringliteral">&quot;help,h&quot;</span>, <span class="stringliteral">&quot;produce help message&quot;</span>)
<a name="l00062"></a>00062   (<span class="stringliteral">&quot;target-output,o&quot;</span>,
<a name="l00063"></a>00063    po::value&lt;string&gt;(&amp;target_output)-&gt;default_value(target_output),
<a name="l00064"></a>00064    <span class="stringliteral">&quot;file to write target protobufs to&quot;</span>)
<a name="l00065"></a>00065   (<span class="stringliteral">&quot;fr-stranded&quot;</span>,
<a name="l00066"></a>00066    <span class="stringliteral">&quot;accept only forward-&gt;reverse alignments (second-stranded protocols)&quot;</span>)
<a name="l00067"></a>00067   (<span class="stringliteral">&quot;rf-stranded&quot;</span>,
<a name="l00068"></a>00068    <span class="stringliteral">&quot;accept only reverse-&gt;forward alignments (first-stranded protocols)&quot;</span>)
<a name="l00069"></a>00069   ;
<a name="l00070"></a>00070   
<a name="l00071"></a>00071   po::options_description advanced(<span class="stringliteral">&quot;Advanced Options&quot;</span>);
<a name="l00072"></a>00072   advanced.add_options()
<a name="l00073"></a>00073   (<span class="stringliteral">&quot;max-indel-size&quot;</span>,
<a name="l00074"></a>00074    po::value&lt;size_t&gt;(&amp;max_indel_size)-&gt;default_value(max_indel_size),
<a name="l00075"></a>00075    <span class="stringliteral">&quot;sets the maximum allowed indel size, affecting geometric indel prior&quot;</span>)
<a name="l00076"></a>00076   (<span class="stringliteral">&quot;stop-at&quot;</span>, po::value&lt;size_t&gt;(&amp;stop_at)-&gt;default_value(stop_at),
<a name="l00077"></a>00077    <span class="stringliteral">&quot;sets the number of fragments to process, disabled with 0&quot;</span>)
<a name="l00078"></a>00078   ;
<a name="l00079"></a>00079   
<a name="l00080"></a>00080   po::options_description hidden(<span class="stringliteral">&quot;Hidden Options&quot;</span>);
<a name="l00081"></a>00081   hidden.add_options()
<a name="l00082"></a>00082   (<span class="stringliteral">&quot;sam-file&quot;</span>, po::value&lt;string&gt;(&amp;in_map_filename)-&gt;default_value(<span class="stringliteral">&quot;&quot;</span>), <span class="stringliteral">&quot;&quot;</span>)
<a name="l00083"></a>00083   (<span class="stringliteral">&quot;fasta-file&quot;</span>, po::value&lt;string&gt;(&amp;fasta_filename)-&gt;default_value(<span class="stringliteral">&quot;&quot;</span>), <span class="stringliteral">&quot;&quot;</span>)
<a name="l00084"></a>00084   ;
<a name="l00085"></a>00085   
<a name="l00086"></a>00086   po::positional_options_description positional;
<a name="l00087"></a>00087   positional.add(<span class="stringliteral">&quot;fasta-file&quot;</span>,1).add(<span class="stringliteral">&quot;sam-file&quot;</span>,1);
<a name="l00088"></a>00088   
<a name="l00089"></a>00089   po::options_description cmdline_options;
<a name="l00090"></a>00090   cmdline_options.add(standard).add(advanced).add(hidden);
<a name="l00091"></a>00091   
<a name="l00092"></a>00092   <span class="keywordtype">bool</span> error = <span class="keyword">false</span>;
<a name="l00093"></a>00093   po::variables_map vm;
<a name="l00094"></a>00094   <span class="keywordflow">try</span> {
<a name="l00095"></a>00095     po::store(po::command_line_parser(ac, av).options(cmdline_options)
<a name="l00096"></a>00096               .positional(positional).run(), vm);
<a name="l00097"></a>00097   } <span class="keywordflow">catch</span> (po::error&amp; e) {
<a name="l00098"></a>00098     cerr &lt;&lt; <span class="stringliteral">&quot;Command-Line Argument Error: &quot;</span>&lt;&lt; e.what() &lt;&lt; endl;
<a name="l00099"></a>00099     error = <span class="keyword">true</span>;
<a name="l00100"></a>00100   }
<a name="l00101"></a>00101   po::notify(vm);
<a name="l00102"></a>00102   
<a name="l00103"></a>00103   <span class="keywordflow">if</span> (fasta_filename == <span class="stringliteral">&quot;&quot;</span>) {
<a name="l00104"></a>00104     cerr &lt;&lt; <span class="stringliteral">&quot;Command-Line Argument Error: target sequence fasta file &quot;</span>
<a name="l00105"></a>00105     &lt;&lt; <span class="stringliteral">&quot;required\n\n&quot;</span>;
<a name="l00106"></a>00106     error = <span class="keyword">true</span>;
<a name="l00107"></a>00107   }
<a name="l00108"></a>00108   
<a name="l00109"></a>00109   <span class="keywordflow">if</span> (error || vm.count(<span class="stringliteral">&quot;help&quot;</span>)) {
<a name="l00110"></a>00110     cerr &lt;&lt; <span class="stringliteral">&quot;express v&quot;</span> &lt;&lt; PACKAGE_VERSION &lt;&lt; endl
<a name="l00111"></a>00111     &lt;&lt; <span class="stringliteral">&quot;-----------------------------\n&quot;</span>
<a name="l00112"></a>00112     &lt;&lt; <span class="stringliteral">&quot;File Usage:  express [options] &lt;target_seqs.fa&gt; &lt;hits.(sam/bam)&gt;\n&quot;</span>
<a name="l00113"></a>00113     &lt;&lt; <span class="stringliteral">&quot;Piped Usage: bowtie [options] -S &lt;index&gt; &lt;reads.fq&gt; | express &quot;</span>
<a name="l00114"></a>00114     &lt;&lt; <span class="stringliteral">&quot;[options] &lt;target_seqs.fa&gt;\n\n&quot;</span>
<a name="l00115"></a>00115     &lt;&lt; <span class="stringliteral">&quot;Required arguments:\n&quot;</span>
<a name="l00116"></a>00116     &lt;&lt; <span class="stringliteral">&quot; &lt;target_seqs.fa&gt;     target sequence file in fasta format\n&quot;</span>
<a name="l00117"></a>00117     &lt;&lt; <span class="stringliteral">&quot; &lt;hits.(sam/bam)&gt;     read alignment file in SAM or BAM format\n\n&quot;</span>
<a name="l00118"></a>00118     &lt;&lt; standard
<a name="l00119"></a>00119     &lt;&lt; advanced;
<a name="l00120"></a>00120     <span class="keywordflow">return</span> 1;
<a name="l00121"></a>00121   }
<a name="l00122"></a>00122   
<a name="l00123"></a>00123   <span class="keywordflow">if</span> (vm.count(<span class="stringliteral">&quot;fr-stranded&quot;</span>)) {
<a name="l00124"></a>00124     direction = FR;
<a name="l00125"></a>00125   }
<a name="l00126"></a>00126   
<a name="l00127"></a>00127   <span class="keywordflow">if</span> (vm.count(<span class="stringliteral">&quot;rf-stranded&quot;</span>)) {
<a name="l00128"></a>00128     <span class="keywordflow">if</span> (direction != BOTH) {
<a name="l00129"></a>00129       cerr &lt;&lt; <span class="stringliteral">&quot;ERROR fr-stranded and rf-stranded flags cannot both be &quot;</span>
<a name="l00130"></a>00130       &lt;&lt; <span class="stringliteral">&quot;specified in the same run.\n&quot;</span>;
<a name="l00131"></a>00131       <span class="keywordflow">return</span> 1;
<a name="l00132"></a>00132     }
<a name="l00133"></a>00133     direction = RF;
<a name="l00134"></a>00134   }
<a name="l00135"></a>00135   
<a name="l00136"></a>00136 <span class="preprocessor">#ifndef WIN32</span>
<a name="l00137"></a>00137 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (!vm.count(<span class="stringliteral">&quot;no-update-check&quot;</span>)) {
<a name="l00138"></a>00138     check_version(PACKAGE_VERSION);
<a name="l00139"></a>00139   }
<a name="l00140"></a>00140 <span class="preprocessor">#endif</span>
<a name="l00141"></a>00141 <span class="preprocessor"></span>  
<a name="l00142"></a>00142   <span class="keywordflow">return</span> 0;
<a name="l00143"></a>00143 }
<a name="l00144"></a>00144 
<a name="l00145"></a>00145 <span class="keyword">inline</span> <span class="keywordtype">string</span> base64_encode(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; to_encode) {
<a name="l00146"></a>00146   <span class="keyword">using namespace </span>boost::archive::iterators;
<a name="l00147"></a>00147   <span class="keyword">typedef</span> base64_from_binary&lt;transform_width&lt;string::const_iterator,6,8&gt; &gt; it_base64_t;
<a name="l00148"></a>00148   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> writePaddChars = (3-to_encode.length()%3)%3;
<a name="l00149"></a>00149   <span class="keywordtype">string</span> base64(it_base64_t(to_encode.begin()), it_base64_t(to_encode.end()));
<a name="l00150"></a>00150   base64.append(writePaddChars,<span class="charliteral">&#39;=&#39;</span>);
<a name="l00151"></a>00151   <span class="keywordflow">return</span> base64;
<a name="l00152"></a>00152 }
<a name="l00153"></a>00153 
<a name="l00154"></a>00154 <span class="keywordtype">int</span> preprocess_main() {
<a name="l00155"></a>00155   <a class="code" href="class_librarian.html" title="The Librarian class keeps track of the different library objects for a run.">Librarian</a> libs(1);
<a name="l00156"></a>00156   <a class="code" href="struct_library.html" title="library.h express">Library</a>&amp; lib = libs[0];
<a name="l00157"></a>00157   lib.<a class="code" href="struct_library.html#adbabd301c82ac1cc515450af14881a50" title="Path to the input file.">in_file_name</a> = in_map_filename;
<a name="l00158"></a>00158   lib.<a class="code" href="struct_library.html#a58ad2be1dd01a1e4eb35f5266c1d00a8" title="Path to the out file.">out_file_name</a> = <span class="stringliteral">&quot;&quot;</span>;
<a name="l00159"></a>00159 
<a name="l00160"></a>00160   lib.<a class="code" href="struct_library.html#a91e1bac8fa14d47e8042f3d27966f43f" title="A pointer to the MapParser for parsing the input alignment file for this library.">map_parser</a>.reset(<span class="keyword">new</span> <a class="code" href="class_map_parser.html" title="The MapParser class is meant to be run as a separate thread from the main processing.">MapParser</a> (&amp;lib, <span class="keyword">false</span>));
<a name="l00161"></a>00161   lib.<a class="code" href="struct_library.html#a607ad9db8ce921d5cbee04d71445ee38" title="A pointer to the fragment length distribution object for this library.">fld</a>.reset(<span class="keyword">new</span> <a class="code" href="class_length_distribution.html" title="lengthdistribution.h express">LengthDistribution</a>(0, 0, 0, 1, 2, 0));
<a name="l00162"></a>00162   <a class="code" href="class_markov_model.html" title="The MarkovModel class is used to store transition probabilities of a Markov chain based on a nucleoti...">MarkovModel</a> bias_model(3, 21, 21, 0);
<a name="l00163"></a>00163   <a class="code" href="class_mismatch_table.html" title="The MismatchTable class is used to store and update mismatch and indel (error) parameters using a fir...">MismatchTable</a> mismatch_table(0);
<a name="l00164"></a>00164   lib.<a class="code" href="struct_library.html#a0d03282745e85e170cbe52b5c57dfb63" title="A pointer to the TargetTable containing the target parameters (abundance, effective length) for this ...">targ_table</a>.reset(<span class="keyword">new</span> <a class="code" href="class_target_table.html" title="The TargetTable class is used to keep track of the Target objects for a run.">TargetTable</a> (fasta_filename, <span class="stringliteral">&quot;&quot;</span>, 0, 0, NULL, NULL,
<a name="l00165"></a>00165                                         &amp;libs));
<a name="l00166"></a>00166   
<a name="l00167"></a>00167   cerr &lt;&lt; <span class="stringliteral">&quot;Converting targets to Protocol Buffers...\n&quot;</span>;
<a name="l00168"></a>00168   fstream targ_out(target_output.c_str(),
<a name="l00169"></a>00169                    ios::out | ios::trunc);
<a name="l00170"></a>00170   <span class="keywordtype">string</span> out_buff;
<a name="l00171"></a>00171   proto::Target target_proto;
<a name="l00172"></a>00172   <span class="keywordflow">for</span> (TargID <span class="keywordtype">id</span> = 0; <span class="keywordtype">id</span> &lt; lib.<a class="code" href="struct_library.html#a0d03282745e85e170cbe52b5c57dfb63" title="A pointer to the TargetTable containing the target parameters (abundance, effective length) for this ...">targ_table</a>-&gt;size(); ++id) {
<a name="l00173"></a>00173     target_proto.Clear();
<a name="l00174"></a>00174     <a class="code" href="class_target.html" title="The Target class is used to store objects for the targets being mapped to.">Target</a>&amp; targ = *lib.<a class="code" href="struct_library.html#a0d03282745e85e170cbe52b5c57dfb63" title="A pointer to the TargetTable containing the target parameters (abundance, effective length) for this ...">targ_table</a>-&gt;get_targ(<span class="keywordtype">id</span>);
<a name="l00175"></a>00175     target_proto.set_name(targ.<a class="code" href="class_target.html#a8534c03431aa63d07defca5f90f0fbad" title="An accessor for the target name.">name</a>());
<a name="l00176"></a>00176     target_proto.set_id((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)targ.<a class="code" href="class_target.html#a321594c9b0d800af152d40b593bdddc3" title="An accessor for the target id.">id</a>());
<a name="l00177"></a>00177     target_proto.set_length((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)targ.<a class="code" href="class_target.html#aaff6b643c19808545062bd1489147c92" title="An accessor for the length of the target sequence.">length</a>());
<a name="l00178"></a>00178     
<a name="l00179"></a>00179     vector&lt;char&gt; bias_indices_l = bias_model.get_indices(targ.<a class="code" href="class_target.html#a8fec0cb27d4ae3d7b31059250428efb4" title="An accessor for the the target&amp;#39;s Sequence (const).">seq</a>(0));
<a name="l00180"></a>00180     target_proto.set_bias_indices_l(<span class="keywordtype">string</span>(bias_indices_l.begin(),
<a name="l00181"></a>00181                                            bias_indices_l.end()));
<a name="l00182"></a>00182     
<a name="l00183"></a>00183     vector&lt;char&gt; bias_indices_r = bias_model.get_indices(targ.<a class="code" href="class_target.html#a8fec0cb27d4ae3d7b31059250428efb4" title="An accessor for the the target&amp;#39;s Sequence (const).">seq</a>(1));
<a name="l00184"></a>00184     target_proto.set_bias_indices_r(<span class="keywordtype">string</span>(bias_indices_r.begin(),
<a name="l00185"></a>00185                                            bias_indices_r.end()));
<a name="l00186"></a>00186     
<a name="l00187"></a>00187     target_proto.SerializeToString(&amp;out_buff);
<a name="l00188"></a>00188     targ_out &lt;&lt; base64_encode(out_buff) &lt;&lt; endl;
<a name="l00189"></a>00189   }
<a name="l00190"></a>00190   targ_out.close();
<a name="l00191"></a>00191   
<a name="l00192"></a>00192   cerr &lt;&lt; <span class="stringliteral">&quot;Converting fragment alignments to Protocol Buffers..\n&quot;</span>;
<a name="l00193"></a>00193   ostream frag_out(cout.rdbuf());
<a name="l00194"></a>00194   
<a name="l00195"></a>00195   <span class="keywordtype">size_t</span> num_frags = 0;
<a name="l00196"></a>00196   cerr &lt;&lt; setiosflags(ios::left);
<a name="l00197"></a>00197   <a class="code" href="class_fragment.html" title="The Fragment class stores information for all alignments of a single fragment.">Fragment</a>* frag;
<a name="l00198"></a>00198   
<a name="l00199"></a>00199   <a class="code" href="struct_parse_thread_safety.html" title="The ParseThreadSafety struct stores objects to allow for parsing to safely occur on a separate thread...">ParseThreadSafety</a> pts(10);
<a name="l00200"></a>00200   boost::thread parse(&amp;<a class="code" href="class_map_parser.html#afe5489ad414dd40681ab6df8425a2f5d" title="A member function that drives the parse thread.">MapParser::threaded_parse</a>, lib.<a class="code" href="struct_library.html#a91e1bac8fa14d47e8042f3d27966f43f" title="A pointer to the MapParser for parsing the input alignment file for this library.">map_parser</a>.get(), &amp;pts,
<a name="l00201"></a>00201                       stop_at, 0);
<a name="l00202"></a>00202   <a class="code" href="class_roberts_filter.html" title="The RobertsFilter class implements a datastructure to test for repeats of a key with high probability...">RobertsFilter</a> frags_seen;
<a name="l00203"></a>00203   proto::Fragment frag_proto;
<a name="l00204"></a>00204   <span class="keywordflow">while</span>(<span class="keyword">true</span>) {
<a name="l00205"></a>00205     frag_proto.Clear();
<a name="l00206"></a>00206     
<a name="l00207"></a>00207     <span class="comment">// Pop next parsed fragment and set mass</span>
<a name="l00208"></a>00208     frag = pts.proc_in.pop();
<a name="l00209"></a>00209     
<a name="l00210"></a>00210     <span class="keywordflow">if</span> (!frag) {
<a name="l00211"></a>00211       <span class="keywordflow">break</span>;
<a name="l00212"></a>00212     }
<a name="l00213"></a>00213     
<a name="l00214"></a>00214     <span class="comment">// Test that we have not already seen this fragment</span>
<a name="l00215"></a>00215     <span class="keywordflow">if</span> (frags_seen.test_and_push(frag-&gt;<a class="code" href="class_fragment.html#a8c633e802207ee017022008cf7ad5b3e" title="A member function that returns a reference to the &amp;quot;Query Template Name&amp;quot;.">name</a>())) {
<a name="l00216"></a>00216       cerr &lt;&lt; <span class="stringliteral">&quot;ERROR: Alignments are not properly sorted. Read &#39;&quot;</span>
<a name="l00217"></a>00217       &lt;&lt; frag-&gt;<a class="code" href="class_fragment.html#a8c633e802207ee017022008cf7ad5b3e" title="A member function that returns a reference to the &amp;quot;Query Template Name&amp;quot;.">name</a>() &lt;&lt; <span class="stringliteral">&quot;&#39; has alignments which are non-consecutive.\n&quot;</span>;
<a name="l00218"></a>00218       exit(1);
<a name="l00219"></a>00219     }
<a name="l00220"></a>00220     
<a name="l00221"></a>00221     frag_proto.set_paired(frag-&gt;<a class="code" href="class_fragment.html#a658722eacfcde40c75adf920da0f2e7e" title="An accessor that returns true iff the Fragment has paired alignments.">paired</a>());
<a name="l00222"></a>00222     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; frag-&gt;<a class="code" href="class_fragment.html#aa872b9915b89c435894befdd7d21c14c" title="An accessor for the number of valid alignments of the fragment.">num_hits</a>(); ++i) {
<a name="l00223"></a>00223       <a class="code" href="class_frag_hit.html" title="The FragHit struct stores the information for a single fragment alignment.">FragHit</a>&amp; fh = *(*frag)[i];
<a name="l00224"></a>00224       proto::FragmentAlignment&amp; align_proto = *frag_proto.add_alignments();
<a name="l00225"></a>00225       align_proto.set_target_id((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)fh.<a class="code" href="class_frag_hit.html#a7835fa361843ab140f32217a5dff3954" title="Accessor for the ID of the target the fragment is aligned to.">target_id</a>());
<a name="l00226"></a>00226       align_proto.set_length((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)fh.<a class="code" href="class_frag_hit.html#a3ac63fe1e9dd8310d84528e71550c4e5" title="Accessor for the length of the fragment alignment.">length</a>());
<a name="l00227"></a>00227       
<a name="l00228"></a>00228       vector&lt;char&gt; left_mm_indices;
<a name="l00229"></a>00229       vector&lt;char&gt; right_mm_indices;
<a name="l00230"></a>00230       
<a name="l00231"></a>00231       mismatch_table.get_indices(fh, left_mm_indices, right_mm_indices);
<a name="l00232"></a>00232       
<a name="l00233"></a>00233       <a class="code" href="struct_read_hit.html" title="The ReadHit struct stores information for a single read alignment.">ReadHit</a>* read_l = fh.<a class="code" href="class_frag_hit.html#a33b532474f91db7f85fd43c80891bab5" title="Const accessor for the alignment of the read at the leftmost (5&amp;#39;) end of the fragment in target c...">left_read</a>();
<a name="l00234"></a>00234       <span class="keywordflow">if</span> (read_l) {
<a name="l00235"></a>00235         proto::ReadAlignment&amp; read_proto = *align_proto.mutable_read_l();
<a name="l00236"></a>00236         read_proto.set_first(read_l-&gt;<a class="code" href="struct_read_hit.html#a5daf36ac9dba931f6681c6b59a74129b" title="A public bool specifying if this read was sequenced first according to the SAM flag.">first</a>);
<a name="l00237"></a>00237         read_proto.set_error_indices(<span class="keywordtype">string</span>(left_mm_indices.begin(),
<a name="l00238"></a>00238                                             left_mm_indices.end()));
<a name="l00239"></a>00239         vector&lt;char&gt; bias_indices;
<a name="l00240"></a>00240         <span class="keywordtype">size_t</span> start_pos = bias_model.get_indices(fh.<a class="code" href="class_frag_hit.html#aa660bbd3c47cda99eb9a4591804b5f26" title="Accessor for a pointer to the Target object the fragment is aligned to.">target</a>()-&gt;<a class="code" href="class_target.html#a8fec0cb27d4ae3d7b31059250428efb4" title="An accessor for the the target&amp;#39;s Sequence (const).">seq</a>(0),
<a name="l00241"></a>00241                                                   (int)read_l-&gt;<a class="code" href="struct_read_hit.html#a4ef75693827dceef555dad48875fc0d7" title="A public size_t containing the 0-based leftmost coordinate mapped to in the target.">left</a>,
<a name="l00242"></a>00242                                                   bias_indices);
<a name="l00243"></a>00243         read_proto.set_bias_start_pos((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)start_pos);
<a name="l00244"></a>00244         read_proto.set_bias_indices(<span class="keywordtype">string</span>(bias_indices.begin(),
<a name="l00245"></a>00245                                            bias_indices.end()));
<a name="l00246"></a>00246       }
<a name="l00247"></a>00247 
<a name="l00248"></a>00248       <a class="code" href="struct_read_hit.html" title="The ReadHit struct stores information for a single read alignment.">ReadHit</a>* read_r = fh.<a class="code" href="class_frag_hit.html#ae644ca4a90af3c8a404e3af5f032e55f" title="Const accessor for the alignment of the read at the rightmost (3&amp;#39;) end of the fragment in target ...">right_read</a>();
<a name="l00249"></a>00249       <span class="keywordflow">if</span> (read_r) {
<a name="l00250"></a>00250         proto::ReadAlignment&amp; read_proto = *align_proto.mutable_read_r();
<a name="l00251"></a>00251         read_proto.set_first(read_r-&gt;<a class="code" href="struct_read_hit.html#a5daf36ac9dba931f6681c6b59a74129b" title="A public bool specifying if this read was sequenced first according to the SAM flag.">first</a>);
<a name="l00252"></a>00252         read_proto.set_error_indices(<span class="keywordtype">string</span>(right_mm_indices.begin(),
<a name="l00253"></a>00253                                             right_mm_indices.end()));
<a name="l00254"></a>00254         vector&lt;char&gt; bias_indices;
<a name="l00255"></a>00255         <span class="keywordtype">size_t</span> start_pos = bias_model.get_indices(fh.<a class="code" href="class_frag_hit.html#aa660bbd3c47cda99eb9a4591804b5f26" title="Accessor for a pointer to the Target object the fragment is aligned to.">target</a>()-&gt;<a class="code" href="class_target.html#a8fec0cb27d4ae3d7b31059250428efb4" title="An accessor for the the target&amp;#39;s Sequence (const).">seq</a>(1),
<a name="l00256"></a>00256                                                   (int)(fh.<a class="code" href="class_frag_hit.html#aa660bbd3c47cda99eb9a4591804b5f26" title="Accessor for a pointer to the Target object the fragment is aligned to.">target</a>()-&gt;<a class="code" href="class_target.html#aaff6b643c19808545062bd1489147c92" title="An accessor for the length of the target sequence.">length</a>()
<a name="l00257"></a>00257                                                         - read_r-&gt;<a class="code" href="struct_read_hit.html#a5f8ca879f433d21f65215388aae77406" title="A public size_t containing the position following the 0-based rightmost coordinate mapped to in the t...">right</a>),
<a name="l00258"></a>00258                                                   bias_indices);
<a name="l00259"></a>00259         read_proto.set_bias_start_pos((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)start_pos);
<a name="l00260"></a>00260         read_proto.set_bias_indices(<span class="keywordtype">string</span>(bias_indices.begin(),
<a name="l00261"></a>00261                                            bias_indices.end()));
<a name="l00262"></a>00262       }
<a name="l00263"></a>00263     }
<a name="l00264"></a>00264     frag_proto.SerializeToString(&amp;out_buff);
<a name="l00265"></a>00265     frag_out &lt;&lt; base64_encode(out_buff) &lt;&lt; endl;
<a name="l00266"></a>00266     
<a name="l00267"></a>00267     pts.proc_out.push(frag);
<a name="l00268"></a>00268     
<a name="l00269"></a>00269     num_frags++;
<a name="l00270"></a>00270     
<a name="l00271"></a>00271     <span class="comment">// Output progress</span>
<a name="l00272"></a>00272     <span class="keywordflow">if</span> (num_frags % 1000000 == 0) {
<a name="l00273"></a>00273       cerr &lt;&lt; <span class="stringliteral">&quot;Fragments Processed: &quot;</span> &lt;&lt; setw(9) &lt;&lt; num_frags &lt;&lt; endl;
<a name="l00274"></a>00274     }
<a name="l00275"></a>00275   }
<a name="l00276"></a>00276   
<a name="l00277"></a>00277   parse.join();
<a name="l00278"></a>00278   
<a name="l00279"></a>00279   <span class="keywordflow">return</span> 0;
<a name="l00280"></a>00280 }
<a name="l00281"></a>00281 
<a name="l00282"></a>00282 
<a name="l00283"></a>00283 <span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> * argv[])
<a name="l00284"></a>00284 {
<a name="l00285"></a>00285   <span class="keywordtype">int</span> parse_ret = parse_options(argc, argv);
<a name="l00286"></a>00286   <span class="keywordflow">if</span> (parse_ret) {
<a name="l00287"></a>00287     <span class="keywordflow">return</span> parse_ret;
<a name="l00288"></a>00288   }
<a name="l00289"></a>00289   
<a name="l00290"></a>00290   <span class="keywordflow">return</span> preprocess_main();
<a name="l00291"></a>00291 }
<a name="l00292"></a>00292 
</pre></div></div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><b>express-spark.cpp</b>      </li>
      <li class="footer">Generated on Fri Mar 15 2013 13:51:57 for eXpress by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


</body>
</html>
